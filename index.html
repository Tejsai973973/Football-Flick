<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Football Flick</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body {
            touch-action: none;
            overflow: hidden;
            background-color: #1a1a1a;
            margin: 0;
            padding: 0;
        }
        canvas {
            display: block;
        }
        /* Custom scrollbar for webkit */
        ::-webkit-scrollbar {
            width: 0px;
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden font-sans text-white select-none relative bg-black" oncontextmenu="return false;">

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 bg-[#1a1a1a] z-50 flex flex-col items-center justify-center transition-opacity duration-500">
        <h1 class="text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400 mb-8 drop-shadow-lg tracking-tighter italic">FOOTBALL FLICK</h1>
        <button id="enter-btn" class="bg-white text-black font-bold text-2xl py-4 px-12 rounded-full hover:bg-gray-200 hover:scale-105 transition transform shadow-[0_0_20px_rgba(255,255,255,0.3)]">
            ENTER
        </button>
    </div>

    <!-- Mode Select Screen -->
    <div id="mode-screen" class="absolute inset-0 bg-[#1a1a1a] z-40 flex flex-col items-center justify-center hidden">
        <h2 class="text-4xl font-bold text-white mb-10">SELECT MODE</h2>
        <div class="flex gap-8">
            <button id="ai-btn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 px-10 rounded-2xl transition transform hover:scale-105 shadow-lg text-xl flex flex-col items-center gap-2 border-b-4 border-blue-800">
                <span>ü§ñ</span>
                <span>PLAY WITH AI</span>
            </button>
            <button id="pvp-btn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-6 px-10 rounded-2xl transition transform hover:scale-105 shadow-lg text-xl flex flex-col items-center gap-2 border-b-4 border-red-800">
                <span>üë•</span>
                <span>2 PLAYER</span>
            </button>
            <button id="online-btn" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-6 px-10 rounded-2xl transition transform hover:scale-105 shadow-lg text-xl flex flex-col items-center gap-2 border-b-4 border-purple-800">
                <span>üåç</span>
                <span>ONLINE 1v1</span>
            </button>
        </div>
    </div>

    <!-- Online Menu -->
    <div id="online-menu" class="absolute inset-0 bg-[#1a1a1a] z-40 flex flex-col items-center justify-center hidden">
        <h2 class="text-4xl font-bold text-white mb-10">ONLINE MULTIPLAYER</h2>
        <div class="flex gap-8">
            <button id="host-btn" class="bg-purple-600 hover:bg-purple-500 text-white font-bold py-6 px-10 rounded-2xl transition transform hover:scale-105 shadow-lg text-xl flex flex-col items-center gap-2 border-b-4 border-purple-800">
                <span>üì°</span>
                <span>HOST GAME</span>
            </button>
            <button id="join-btn" class="bg-orange-600 hover:bg-orange-500 text-white font-bold py-6 px-10 rounded-2xl transition transform hover:scale-105 shadow-lg text-xl flex flex-col items-center gap-2 border-b-4 border-orange-800">
                <span>üîó</span>
                <span>JOIN GAME</span>
            </button>
        </div>
        <button id="online-back-btn" class="mt-8 text-gray-400 hover:text-white underline">Back</button>
    </div>

    <!-- Waiting Screen -->
    <div id="waiting-screen" class="absolute inset-0 bg-[#1a1a1a] z-40 flex flex-col items-center justify-center hidden">
        <h2 class="text-3xl font-bold text-white mb-4">WAITING FOR OPPONENT...</h2>
        <div class="bg-gray-800 p-6 rounded-xl border border-gray-600 flex flex-col items-center">
            <span class="text-gray-400 mb-2">Share this Game ID:</span>
            <div class="flex items-center gap-4">
                <span id="my-id" class="text-5xl font-mono font-black text-blue-400 tracking-widest select-all">---</span>
                <button id="copy-btn" class="bg-gray-700 hover:bg-gray-600 text-white p-2 rounded hover:scale-110 transition">üìã</button>
            </div>
        </div>
        <button id="cancel-host-btn" class="mt-8 text-red-400 hover:text-red-300 underline">Cancel</button>
    </div>

    <!-- Join Input Screen -->
    <div id="join-screen" class="absolute inset-0 bg-[#1a1a1a] z-40 flex flex-col items-center justify-center hidden">
        <h2 class="text-3xl font-bold text-white mb-8">JOIN GAME</h2>
        <input type="text" id="join-id-input" placeholder="ENTER ID" class="bg-gray-800 text-white text-3xl font-mono font-bold py-4 px-8 rounded-xl border-2 border-gray-600 focus:border-blue-500 outline-none mb-6 text-center uppercase w-64" maxlength="4">
        <button id="connect-btn" class="bg-green-600 hover:bg-green-500 text-white font-bold py-4 px-12 rounded-full transition transform hover:scale-105 shadow-lg text-xl border-b-4 border-green-800">
            CONNECT
        </button>
        <button id="cancel-join-btn" class="mt-8 text-gray-400 hover:text-white underline">Cancel</button>
    </div>

    <!-- Formation Select Screen -->
    <div id="formation-screen" class="absolute inset-0 bg-[#1a1a1a] z-30 flex flex-col items-center justify-center hidden">
        <h2 class="text-4xl font-bold text-white mb-8">SELECT FORMATION</h2>
        <div class="flex flex-col md:flex-row gap-6">
            <button id="form-balanced" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition transform hover:scale-105 shadow-lg text-lg flex flex-col items-center border-b-4 border-gray-900 w-48">
                <span class="text-2xl mb-2">‚öñÔ∏è</span>
                <span>BALANCED</span>
                <span class="text-xs text-gray-400 mt-1">1 - 2 - 2</span>
            </button>
            <button id="form-defensive" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition transform hover:scale-105 shadow-lg text-lg flex flex-col items-center border-b-4 border-gray-900 w-48">
                <span class="text-2xl mb-2">üõ°Ô∏è</span>
                <span>DEFENSIVE</span>
                <span class="text-xs text-gray-400 mt-1">1 - 3 - 1</span>
            </button>
            <button id="form-offensive" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition transform hover:scale-105 shadow-lg text-lg flex flex-col items-center border-b-4 border-gray-900 w-48">
                <span class="text-2xl mb-2">‚öîÔ∏è</span>
                <span>OFFENSIVE</span>
                <span class="text-xs text-gray-400 mt-1">1 - 1 - 3</span>
            </button>
        </div>
    </div>

    <!-- UI Header -->
    <div id="game-ui" class="absolute top-4 w-full px-8 flex justify-between items-center z-10 pointer-events-none opacity-0 transition-opacity duration-500">
        <div class="flex flex-col items-center w-24">
            <span class="text-blue-400 font-bold text-xl">BLUE</span>
            <span id="score-blue" class="text-4xl font-black">0</span>
        </div>
        
        <div class="bg-gray-800/80 px-6 py-2 rounded-full border border-gray-600 min-w-[200px] text-center shadow-lg backdrop-blur-sm flex flex-col items-center">
            <span id="turn-indicator" class="font-bold text-lg text-blue-400">BLUE'S TURN</span>
            <span id="timer-display" class="text-3xl font-mono font-black text-white my-1 drop-shadow-md">15.0</span>
            <div class="text-xs text-gray-400">FIRST TO 2 WINS</div>
        </div>

        <div class="flex flex-col items-center w-24">
            <span class="text-red-400 font-bold text-xl">RED</span>
            <span id="score-red" class="text-4xl font-black">0</span>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="absolute inset-0 w-full h-full bg-[#2d6a4f] opacity-0 transition-opacity duration-500">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
        
        <!-- Game Over Modal -->
        <div id="game-over-modal" class="hidden absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-20">
            <h2 id="winner-text" class="text-6xl font-black mb-2 text-white drop-shadow-lg italic">BLUE WINS!</h2>
            <p id="final-score" class="text-2xl text-gray-300 mb-8 font-mono">3 - 1</p>
            <button id="restart-btn" class="pointer-events-auto bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full transition transform hover:scale-105 shadow-lg text-xl border-b-4 border-green-700">
                Main Menu
            </button>
        </div>
    </div>

    <div id="instructions" class="absolute bottom-4 left-0 right-0 text-center text-white/50 text-sm pointer-events-none opacity-0 px-4">
        Touch and drag to shoot. First to 2 goals wins. No direct goals from kickoff!
    </div>

<script>
    // --- Constants & Config ---
    const GAME_WIDTH = 1280;
    const GAME_HEIGHT = 720;
    
    const PITCH_PADDING = 80;
    const PITCH_X = PITCH_PADDING;
    const PITCH_Y = PITCH_PADDING;
    const PITCH_WIDTH = GAME_WIDTH - (PITCH_PADDING * 2);
    const PITCH_HEIGHT = GAME_HEIGHT - (PITCH_PADDING * 2);

    const FRICTION = 0.98;
    const WALL_BOUNCE = 0.7;
    const PLAYER_BOUNCE = 0.8;
    const MAX_POWER = 15;
    const GOAL_WIDTH = 220;
    
    const RADIUS_PLAYER = 25;
    const RADIUS_BALL = 14;
    
    const MASS_PLAYER = 2;
    const MASS_BALL = 1;

    // Colors
    const COLOR_PITCH = '#3a7d44';
    const COLOR_LINES = 'rgba(255, 255, 255, 0.5)';
    const COLOR_BLUE = '#3b82f6';
    const COLOR_RED = '#ef4444';
    const COLOR_BALL = '#ffffff';

    // --- State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const turnIndicator = document.getElementById('turn-indicator');
    const scoreBlueEl = document.getElementById('score-blue');
    const scoreRedEl = document.getElementById('score-red');
    const gameOverModal = document.getElementById('game-over-modal');
    const winnerText = document.getElementById('winner-text');
    const finalScoreText = document.getElementById('final-score');
    const restartBtn = document.getElementById('restart-btn');
    
    const startScreen = document.getElementById('start-screen');
    const modeScreen = document.getElementById('mode-screen');
    const formationScreen = document.getElementById('formation-screen');
    const gameContainer = document.getElementById('game-container');
    const gameUI = document.getElementById('game-ui');
    const instructions = document.getElementById('instructions');
    const timerDisplay = document.getElementById('timer-display');
    
    // Online UI Refs
    const onlineMenu = document.getElementById('online-menu');
    const waitingScreen = document.getElementById('waiting-screen');
    const joinScreen = document.getElementById('join-screen');
    const myIdDisplay = document.getElementById('my-id');
    const joinIdInput = document.getElementById('join-id-input');

    let selectedFormation = 'BALANCED'; // BALANCED, DEFENSIVE, OFFENSIVE
    
    // Online State
    let isOnline = false;
    let isHost = false;
    let peer = null;
    let conn = null;
    let clientFormation = 'BALANCED'; // For Host to know
    let onlineId = '';
    
    // Timer State
    const TURN_TIME_LIMIT = 15.0;
    let turnTimer = TURN_TIME_LIMIT;
    let lastTime = 0;

    // Display Scaling
    let scale = 1;
    let offsetX = 0;
    let offsetY = 0;

    function handleResize() {
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        
        const scaleX = windowWidth / GAME_WIDTH;
        const scaleY = windowHeight / GAME_HEIGHT;
        scale = Math.min(scaleX, scaleY);
        
        canvas.width = windowWidth;
        canvas.height = windowHeight;
        
        offsetX = (windowWidth - GAME_WIDTH * scale) / 2;
        offsetY = (windowHeight - GAME_HEIGHT * scale) / 2;
    }
    
    window.addEventListener('resize', handleResize);
    handleResize();

    let gameState = 'MENU'; // MENU, MODE_SELECT, PLAYING, MOVING, SCORING, GAME_OVER, FOUL
    let turn = 'BLUE'; 
    let scores = { blue: 0, red: 0 };
    let entities = [];
    let ball;
    
    // Game Mode State
    let isVsAI = false;
    let isKickoff = true; // Tracks if it's the first move after a reset

    // Input State
    let dragStart = null;
    let dragCurrent = null;
    let selectedEntity = null;

    // --- Physics Engine Classes ---
    class Vector {
        constructor(x, y) { this.x = x; this.y = y; }
        add(v) { return new Vector(this.x + v.x, this.y + v.y); }
        sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
        mult(n) { return new Vector(this.x * n, this.y * n); }
        mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        normalize() { 
            const m = this.mag(); 
            return m === 0 ? new Vector(0,0) : new Vector(this.x / m, this.y / m); 
        }
        dot(v) { return this.x * v.x + this.y * v.y; }
    }

    class Entity {
        constructor(x, y, radius, mass, type, team = null) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(0, 0);
            this.radius = radius;
            this.mass = mass;
            this.type = type;
            this.team = team;
        }

        update() {
            this.pos = this.pos.add(this.vel);
            this.vel = this.vel.mult(FRICTION);
            
            if (this.vel.mag() < 0.05) {
                this.vel = new Vector(0, 0);
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            if (this.type === 'ball') {
                ctx.fillStyle = COLOR_BALL;
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                const angleOffset = (this.pos.x + this.pos.y) * 0.05;
                for (let i = 0; i < 5; i++) {
                    const a = angleOffset + (i * Math.PI * 2) / 5;
                    const px = this.pos.x + Math.cos(a) * (this.radius * 0.65);
                    const py = this.pos.y + Math.sin(a) * (this.radius * 0.65);
                    ctx.beginPath();
                    ctx.arc(px, py, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
            } else {
                ctx.fillStyle = this.team === 'BLUE' ? COLOR_BLUE : COLOR_RED;
                if (this.team === turn && gameState === 'PLAYING') {
                    ctx.shadowColor = this.team === 'BLUE' ? '#60a5fa' : '#f87171';
                    ctx.shadowBlur = 15;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius * 0.7, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                if (selectedEntity === this && gameState === 'PLAYING') {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 4, 0, Math.PI * 2);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                } else if (this.team === turn && gameState === 'PLAYING') {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 2, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            ctx.shadowColor = 'transparent';
        }
    }

    // --- Game Logic ---

    function initGame() {
        entities = [];
        ball = new Entity(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT / 2, RADIUS_BALL, MASS_BALL, 'ball');
        entities.push(ball);
        resetPositions();
        
        // Setup Menu Listeners
        document.getElementById('enter-btn').addEventListener('click', () => {
            startScreen.classList.add('hidden');
            modeScreen.classList.remove('hidden');
            modeScreen.classList.add('flex');
            gameState = 'MODE_SELECT';
        });

        document.getElementById('pvp-btn').addEventListener('click', () => {
            isVsAI = false;
            showFormationSelect();
        });

        document.getElementById('ai-btn').addEventListener('click', () => {
            isVsAI = true;
            showFormationSelect();
        });

        function handleFormationChoice(fmt) {
            selectedFormation = fmt;
            
            if (isOnline) {
                formationScreen.classList.add('hidden');
                formationScreen.classList.remove('flex');
                
                if (isHost) {
                     // Host picked, now wait for client to pick
                     waitingScreen.classList.remove('hidden');
                     waitingScreen.classList.add('flex');
                     document.querySelector('#waiting-screen h2').textContent = "OPPONENT SELECTING...";
                     
                     if (conn && conn.open) {
                         conn.send({ type: 'FORMATION_REQUEST' });
                     }
                } else {
                     // Client picked, send to host
                     conn.send({ type: 'FORMATION_RESPONSE', formation: selectedFormation });
                     instructions.textContent = "Waiting for Host to start game...";
                     instructions.classList.remove('opacity-0');
                }
            } else {
                startGame();
            }
        }

        document.getElementById('form-balanced').addEventListener('click', () => handleFormationChoice('BALANCED'));
        document.getElementById('form-defensive').addEventListener('click', () => handleFormationChoice('DEFENSIVE'));
        document.getElementById('form-offensive').addEventListener('click', () => handleFormationChoice('OFFENSIVE'));

        // Online Listeners
        document.getElementById('online-btn').addEventListener('click', () => {
            modeScreen.classList.add('hidden');
            modeScreen.classList.remove('flex');
            onlineMenu.classList.remove('hidden');
            onlineMenu.classList.add('flex');
        });

        document.getElementById('online-back-btn').addEventListener('click', () => {
            onlineMenu.classList.add('hidden');
            onlineMenu.classList.remove('flex');
            modeScreen.classList.remove('hidden');
            modeScreen.classList.add('flex');
        });

        document.getElementById('host-btn').addEventListener('click', () => {
            isOnline = true;
            isHost = true;
            onlineMenu.classList.add('hidden');
            onlineMenu.classList.remove('flex');
            
            // Show waiting screen immediately so user sees Code
            waitingScreen.classList.remove('hidden');
            waitingScreen.classList.add('flex');
            document.querySelector('#waiting-screen h2').textContent = "WAITING FOR OPPONENT...";
            
            initPeer(); 
        });

        document.getElementById('join-btn').addEventListener('click', () => {
            isOnline = true;
            isHost = false;
            onlineMenu.classList.add('hidden');
            onlineMenu.classList.remove('flex');
            joinScreen.classList.remove('hidden');
            joinScreen.classList.add('flex');
        });

        document.getElementById('cancel-host-btn').addEventListener('click', () => {
             // Reset peer
             if(peer) peer.destroy();
             isOnline = false;
             waitingScreen.classList.add('hidden');
             waitingScreen.classList.remove('flex');
             onlineMenu.classList.remove('hidden');
             onlineMenu.classList.add('flex');
        });

        document.getElementById('connect-btn').addEventListener('click', () => {
            const id = joinIdInput.value.toUpperCase();
            if (id.length === 4) {
                initPeer(id);
                joinScreen.classList.add('hidden');
                joinScreen.classList.remove('flex');
                // Show generic loading?
                instructions.textContent = "Connecting...";
                instructions.classList.remove('opacity-0');
            }
        });

        document.getElementById('cancel-join-btn').addEventListener('click', () => {
            isOnline = false;
            joinScreen.classList.add('hidden');
            joinScreen.classList.remove('flex');
            onlineMenu.classList.remove('hidden');
            onlineMenu.classList.add('flex');
        });
        
        document.getElementById('copy-btn').addEventListener('click', () => {
            navigator.clipboard.writeText(onlineId);
            const btn = document.getElementById('copy-btn');
            btn.textContent = '‚úÖ';
            setTimeout(() => btn.textContent = 'üìã', 1000);
        });
    }

    function showFormationSelect() {
        modeScreen.classList.add('hidden');
        modeScreen.classList.remove('flex');
        formationScreen.classList.remove('hidden');
        formationScreen.classList.add('flex');
    }

    function generateId() {
        const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789';
        let result = '';
        for (let i = 0; i < 4; i++) {
            result += chars.charAt(Math.floor(Math.random() * chars.length));
        }
        return result;
    }

    function initPeer(targetId = null) {
        if (peer) peer.destroy();
        
        if (isHost) {
            onlineId = generateId();
            peer = new Peer(onlineId, { debug: 1 }); // Use debug 1 or 2
        } else {
            peer = new Peer(null, { debug: 1 });
        }

        peer.on('open', (id) => {
            console.log('My Peer ID:', id);
            if (isHost) {
                myIdDisplay.textContent = onlineId;
            } else {
                // Connect to host
                conn = peer.connect(targetId);
                setupConnection();
            }
        });

        peer.on('connection', (c) => {
            // Host receives connection
            if (isHost) {
                conn = c;
                setupConnection();
                
                // Connection established, now go to formation select
                waitingScreen.classList.add('hidden');
                waitingScreen.classList.remove('flex');
                showFormationSelect();
            }
        });
        
        peer.on('error', (err) => {
            console.error(err);
            alert("Connection Error: " + err.type);
            // reset UI?
        });
    }

    function setupConnection() {
        conn.on('open', () => {
            console.log('Connected!');
            
            if (!isHost) {
                 // Client connected, wait for formation request
                 // Actually Client needs to select formation first? 
                 // We will show formation screen to client now
                 instructions.classList.add('opacity-0'); // Hide "Connecting..."
                 showFormationSelect();
            }
        });

        conn.on('data', (data) => {
            handleData(data);
        });
        
        conn.on('close', () => {
            alert('Opponent Disconnected');
            location.reload();
        });
    }

    function handleData(data) {
        if (isHost) {
            // Host logic
            if (data.type === 'FORMATION_RESPONSE') {
                clientFormation = data.formation;
                // Both ready
                waitingScreen.classList.add('hidden');
                waitingScreen.classList.remove('flex');
                startGame();
                
                // Send Initial State immediately
                broadcastState();
            } else if (data.type === 'SHOOT') {
                // Client wants to shoot
                // Verify it's RED turn
                if (turn === 'RED' && gameState === 'PLAYING') {
                     // Find the entity
                     // We need to identify entity by index or position? 
                     // Since entities array might change order if filtered... 
                     // Actually resetPositions always pushes in same order.
                     // 0 is ball. 1-5 Blue. 6-10 Red.
                     // Let's rely on index for simplicity in this prototype
                     const entIndex = data.index;
                     if (entities[entIndex] && entities[entIndex].team === 'RED') {
                         entities[entIndex].vel = new Vector(data.vel.x, data.vel.y);
                         gameState = 'MOVING';
                         selectedEntity = null;
                         dragStart = null;
                     }
                }
            }
        } else {
            // Client logic
            if (data.type === 'FORMATION_REQUEST') {
                // Host wants our formation.
                // We might have already selected it?
                if (!formationScreen.classList.contains('hidden')) {
                    // Still selecting
                } else {
                    // Already selected
                    conn.send({ type: 'FORMATION_RESPONSE', formation: selectedFormation });
                }
            } else if (data.type === 'GAME_STATE') {
                // Sync state
                gameState = data.gameState;
                turn = data.turn;
                scores = data.scores;
                turnTimer = data.timer;
                
                // Sync Entities
                if (data.entities.length === entities.length) {
                    for(let i=0; i<entities.length; i++) {
                        entities[i].pos.x = data.entities[i].x;
                        entities[i].pos.y = data.entities[i].y;
                        entities[i].vel.x = data.entities[i].vx;
                        entities[i].vel.y = data.entities[i].vy;
                        entities[i].radius = data.entities[i].r;
                    }
                } else {
                    // Length mismatch (goal reset?), re-sync fully?
                    // Usually implies a resetPositions call missed on client or desync
                    // For now, trust the host's positions if count matches roughly
                }
                
                updateUI();
            } else if (data.type === 'START_GAME') {
                 // Trigger start game locally (visuals)
                 startGame();
            }
        }
    }

    function broadcastState() {
        if (!conn || !conn.open) return;
        
        const entData = entities.map(e => ({
            x: e.pos.x, y: e.pos.y,
            vx: e.vel.x, vy: e.vel.y,
            r: e.radius
        }));
        
        conn.send({
            type: 'GAME_STATE',
            gameState: gameState,
            turn: turn,
            scores: scores,
            timer: turnTimer,
            entities: entData
        });
    }

    function startGame() {
        formationScreen.classList.add('hidden');
        formationScreen.classList.remove('flex');
        
        gameContainer.classList.remove('opacity-0');
        gameUI.classList.remove('opacity-0');
        instructions.classList.remove('opacity-0');
        
        if (isOnline) {
             if (!isHost) {
                 gameUI.classList.add('flex-row-reverse');
             } else {
                 gameUI.classList.remove('flex-row-reverse');
             }
             instructions.textContent = isHost ? "Online: YOU ARE BLUE (HOST)" : "Online: YOU ARE RED (CLIENT)";
             if(isHost) conn.send({ type: 'START_GAME' });
        } else {
             gameUI.classList.remove('flex-row-reverse');
             instructions.textContent = "Touch and drag to shoot. First to 2 goals wins. No direct goals from kickoff!";
        }
        
        // isVsAI is already set
        scores = { blue: 0, red: 0 };
        turn = 'BLUE';
        
        resetPositions();
    }

    function resetPositions() {
        entities = entities.filter(e => e.type === 'ball');
        
        ball.pos = new Vector(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT / 2);
        ball.vel = new Vector(0, 0);

        const w = PITCH_WIDTH;
        const h = PITCH_HEIGHT;
        const startX = PITCH_X;
        const startY = PITCH_Y;
        
        const goalDist = w * 0.08;
        const defDist = w * 0.22;
        const attDist = w * 0.38;
        const spreadY = h * 0.25;
        const attSpreadY = h * 0.15;
        const centerY = startY + h / 2;

        // 5v5 Formations
        // Blue Team (Left)
        
        // Always 1 GK
        entities.push(new Entity(startX + goalDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));

        if (selectedFormation === 'DEFENSIVE') {
            // 1-3-1
            // 3 Defenders
            entities.push(new Entity(startX + defDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + defDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + defDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            // 1 Attacker
            entities.push(new Entity(startX + attDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
        } else if (selectedFormation === 'OFFENSIVE') {
            // 1-1-3
            // 1 Defender
            entities.push(new Entity(startX + defDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            // 3 Attackers
            entities.push(new Entity(startX + attDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + attDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + attDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
        } else {
            // BALANCED (1-2-2)
            // 2 Defenders
            entities.push(new Entity(startX + defDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + defDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            // 2 Attackers
            entities.push(new Entity(startX + attDist, centerY - attSpreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + attDist, centerY + attSpreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
        }

        // Red Team (Right)
        let redForm = isOnline ? clientFormation : 'BALANCED';
        
        // GK
        entities.push(new Entity(startX + w - goalDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));

        if (redForm === 'DEFENSIVE') {
             // 1-3-1
            entities.push(new Entity(startX + w - defDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - defDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - defDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - attDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
        } else if (redForm === 'OFFENSIVE') {
            // 1-1-3
            entities.push(new Entity(startX + w - defDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - attDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - attDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - attDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
        } else {
            // BALANCED
            entities.push(new Entity(startX + w - defDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - defDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - attDist, centerY - attSpreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
            entities.push(new Entity(startX + w - attDist, centerY + attSpreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
        }
        
        gameState = 'PLAYING';
        isKickoff = true; // Set kickoff flag
        updateUI();

        // If AI's turn and AI mode (happens if Red conceded), trigger AI
        if (isVsAI && turn === 'RED') {
            setTimeout(makeAIMove, 1000);
        }
    }

    function checkCollisions() {
        // Walls
        for (let e of entities) {
            if (e.pos.y - e.radius < PITCH_Y) { e.pos.y = PITCH_Y + e.radius; e.vel.y *= -WALL_BOUNCE; } 
            else if (e.pos.y + e.radius > PITCH_Y + PITCH_HEIGHT) { e.pos.y = PITCH_Y + PITCH_HEIGHT - e.radius; e.vel.y *= -WALL_BOUNCE; }

            const goalTop = (GAME_HEIGHT - GOAL_WIDTH) / 2;
            const goalBottom = (GAME_HEIGHT + GOAL_WIDTH) / 2;

            if (e.pos.x - e.radius < PITCH_X) {
                const inGoal = e.pos.y > goalTop && e.pos.y < goalBottom;
                if (inGoal && e.type === 'ball') {
                    if (e.pos.x < PITCH_X - e.radius) handleGoal('RED');
                } else {
                    e.pos.x = PITCH_X + e.radius; e.vel.x *= -WALL_BOUNCE;
                }
            } else if (e.pos.x + e.radius > PITCH_X + PITCH_WIDTH) {
                const inGoal = e.pos.y > goalTop && e.pos.y < goalBottom;
                if (inGoal && e.type === 'ball') {
                    if (e.pos.x > PITCH_X + PITCH_WIDTH + e.radius) handleGoal('BLUE');
                } else {
                    e.pos.x = PITCH_X + PITCH_WIDTH - e.radius; e.vel.x *= -WALL_BOUNCE;
                }
            }
        }

        // Entity-Entity
        for (let iter = 0; iter < 4; iter++) {
            for (let i = 0; i < entities.length; i++) {
                for (let j = i + 1; j < entities.length; j++) {
                    let e1 = entities[i];
                    let e2 = entities[j];
                    let distVec = e1.pos.sub(e2.pos);
                    let dist = distVec.mag();
                    let minDist = e1.radius + e2.radius;

                    if (dist < minDist) {
                        let normal = distVec.normalize();
                        let overlap = minDist - dist;
                        let correction = normal.mult(overlap / 2);
                        e1.pos = e1.pos.add(correction);
                        e2.pos = e2.pos.sub(correction);

                        if (iter === 0) {
                            let relVel = e1.vel.sub(e2.vel);
                            let velAlongNormal = relVel.dot(normal);
                            if (velAlongNormal > 0) continue;
                            let restitution = PLAYER_BOUNCE;
                            let jVal = -(1 + restitution) * velAlongNormal;
                            jVal /= (1 / e1.mass + 1 / e2.mass);
                            let impulse = normal.mult(jVal);
                            e1.vel = e1.vel.add(impulse.mult(1 / e1.mass));
                            e2.vel = e2.vel.sub(impulse.mult(1 / e2.mass));
                        }
                    }
                }
            }
        }
    }

    function isMoving() {
        for (let e of entities) {
            if (e.vel.mag() > 0.1) return true;
        }
        return false;
    }

    function handleGoal(scoringTeam) {
        if (gameState === 'SCORING' || gameState === 'FOUL') return;
        
        // Foul Check: Direct goal from kickoff is disallowed
        if (isKickoff) {
            handleFoul(scoringTeam);
            return;
        }

        gameState = 'SCORING';
        
        if (scoringTeam === 'BLUE') scores.blue++;
        else scores.red++;
        
        updateUI();
        
        setTimeout(() => {
            if (scores.blue >= 2 || scores.red >= 2) {
                endGame();
            } else {
                resetPositions();
                turn = scoringTeam === 'BLUE' ? 'RED' : 'BLUE'; // Conceding team kicks off
                gameState = 'PLAYING';
                updateUI();
            }
        }, 1500);
    }

    function handleFoul(scoringTeam) {
        gameState = 'FOUL';
        // UI Feedback for foul
        setTimeout(() => {
            resetPositions();
            turn = turn === 'BLUE' ? 'RED' : 'BLUE'; 
            gameState = 'PLAYING';
            updateUI();
        }, 2000);
    }

    function endGame() {
        gameState = 'GAME_OVER';
        
        let winner;
        if (scores.blue > scores.red) winner = 'BLUE';
        else if (scores.red > scores.blue) winner = 'RED';
        else winner = 'DRAW';
        
        winnerText.textContent = `${winner} WINS!`;
        winnerText.className = `text-6xl font-black mb-2 drop-shadow-lg italic ${winner === 'BLUE' ? 'text-blue-500' : (winner === 'RED' ? 'text-red-500' : 'text-gray-200')}`;
        
        finalScoreText.textContent = `${scores.blue} - ${scores.red}`;
        
        gameOverModal.classList.remove('hidden');
    }

    function makeAIMove() {
        if (gameState !== 'PLAYING' || turn !== 'RED') return;

        // Simple AI
        const redPlayers = entities.filter(e => e.type === 'player' && e.team === 'RED');
        
        // Find best player to shoot (closest to ball)
        let bestPlayer = null;
        let minDist = Infinity;
        
        for (let p of redPlayers) {
            const d = p.pos.sub(ball.pos).mag();
            if (d < minDist) {
                minDist = d;
                bestPlayer = p;
            }
        }
        
        if (bestPlayer) {
            // Calculate shot vector
            // Target: slightly offset from ball center opposite to goal
            const goalPos = new Vector(PITCH_X, GAME_HEIGHT / 2); // Blue goal
            const ballToGoal = goalPos.sub(ball.pos).normalize();
            
            // We want to hit the ball such that it goes to goal
            // Hit point on ball is opposite to velocity direction we want for ball
            // Desired Ball Vel = Ball->Goal
            // Hit pos = BallPos - BallRadius * BallToGoal
            
            const hitPos = ball.pos.sub(ballToGoal.mult(RADIUS_BALL + RADIUS_PLAYER));
            
            // Vector from player to hitPos
            let shotVec = hitPos.sub(bestPlayer.pos);
            
            // Add some noise for realism
            shotVec.x += (Math.random() - 0.5) * 10;
            shotVec.y += (Math.random() - 0.5) * 10;
            
            // Power
            const power = Math.min(shotVec.mag() * 0.15, MAX_POWER); // Adjust multiplier
            const finalVel = shotVec.normalize().mult(power);
            
            bestPlayer.vel = finalVel;
            gameState = 'MOVING';
            // isKickoff will be handled in the loop when movement stops
        }
    }

    function updateUI() {
        scoreBlueEl.textContent = scores.blue;
        scoreRedEl.textContent = scores.red;
        turnIndicator.textContent = `${turn}'S TURN`;
        turnIndicator.className = `font-bold text-lg ${turn === 'BLUE' ? 'text-blue-400' : 'text-red-400'}`;
        
        // Reset Timer
        turnTimer = TURN_TIME_LIMIT;
        timerDisplay.textContent = turnTimer.toFixed(1);
        timerDisplay.style.color = 'white';

        // Trigger AI if needed
        if (isVsAI && turn === 'RED' && gameState === 'PLAYING') {
            // Small delay for natural feel
            setTimeout(makeAIMove, 800);
        }
    }

    function drawPitch() {
        // Draw background (gutter)
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, GAME_WIDTH, GAME_HEIGHT);

        // Dynamic pitch elements
        const stripeWidth = PITCH_WIDTH / 10;
        for (let i = 0; i < 10; i++) {
            ctx.fillStyle = i % 2 === 0 ? '#3a7d44' : '#326b3a';
            ctx.fillRect(PITCH_X + i * stripeWidth, PITCH_Y, stripeWidth, PITCH_HEIGHT);
        }

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.strokeRect(PITCH_X, PITCH_Y, PITCH_WIDTH, PITCH_HEIGHT);

        // Center line
        ctx.beginPath();
        ctx.moveTo(PITCH_X + PITCH_WIDTH / 2, PITCH_Y);
        ctx.lineTo(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT);
        ctx.stroke();

        // Center circle
        const centerRadius = Math.min(PITCH_WIDTH, PITCH_HEIGHT) * 0.15;
        ctx.beginPath();
        ctx.arc(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT / 2, centerRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT / 2, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        // Goals
        const goalY = (GAME_HEIGHT - GOAL_WIDTH) / 2;
        const goalDepth = PITCH_WIDTH * 0.05;
        
        // Left Goal Box
        ctx.strokeRect(PITCH_X - goalDepth, goalY, goalDepth, GOAL_WIDTH);
        // Right Goal Box
        ctx.strokeRect(PITCH_X + PITCH_WIDTH, goalY, goalDepth, GOAL_WIDTH);
        
        // Nets
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(PITCH_X - goalDepth, goalY, goalDepth, GOAL_WIDTH);
        ctx.fillRect(PITCH_X + PITCH_WIDTH, goalY, goalDepth, GOAL_WIDTH);
    }

    function drawAiming() {
        if (dragStart && dragCurrent && selectedEntity) {
            ctx.beginPath();
            ctx.moveTo(selectedEntity.pos.x, selectedEntity.pos.y);
            let dx = dragCurrent.x - dragStart.x;
            let dy = dragCurrent.y - dragStart.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDrag = 150; 
            const scale = Math.min(dist, maxDrag) / dist || 0;
            let aimX = selectedEntity.pos.x - dx * scale;
            let aimY = selectedEntity.pos.y - dy * scale;

            ctx.lineTo(aimX, aimY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            const angle = Math.atan2(dy, dx);
            const headLen = 15;
            ctx.beginPath();
            ctx.moveTo(aimX, aimY);
            ctx.lineTo(aimX + headLen * Math.cos(angle + Math.PI / 6), aimY + headLen * Math.sin(angle + Math.PI / 6));
            ctx.moveTo(aimX, aimY);
            ctx.lineTo(aimX + headLen * Math.cos(angle - Math.PI / 6), aimY + headLen * Math.sin(angle - Math.PI / 6));
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(selectedEntity.pos.x, selectedEntity.pos.y, selectedEntity.radius + 8, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(scale * 0.8, 0.8)})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000 || 0;
        lastTime = timestamp;

        if (gameState === 'PLAYING') {
            turnTimer -= dt;
            if (turnTimer <= 0) {
                // Timeout! Switch turn
                turnTimer = TURN_TIME_LIMIT;
                turn = turn === 'BLUE' ? 'RED' : 'BLUE';
                // Cancel any active interaction
                dragStart = null;
                selectedEntity = null;
                dragCurrent = null;
                updateUI();
            }
            // Visual Update
            timerDisplay.textContent = Math.max(0, turnTimer).toFixed(1);
            if (turnTimer <= 3.0) timerDisplay.style.color = '#ef4444'; 
            else timerDisplay.style.color = 'white';
        }

        if (gameState !== 'GAME_OVER' && gameState !== 'MENU' && gameState !== 'MODE_SELECT') {
            checkCollisions();
            entities.forEach(e => e.update());
            
            if (isOnline && isHost) {
                broadcastState();
            }

            if (gameState === 'MOVING') {
                if (!isMoving()) {
                    gameState = 'PLAYING';
                    isKickoff = false; // Turn ended, so kickoff state is over
                    turn = turn === 'BLUE' ? 'RED' : 'BLUE';
                    updateUI();
                }
            }
        }

        if (gameState !== 'MENU' && gameState !== 'MODE_SELECT') {
            ctx.save();
            
            // Apply Logical Resolution Transform
            ctx.translate(offsetX, offsetY);
            ctx.scale(scale, scale);
            
            // Clipping to game area
            ctx.beginPath();
            ctx.rect(0, 0, GAME_WIDTH, GAME_HEIGHT);
            ctx.clip();

            if (isOnline && !isHost) {
                ctx.translate(GAME_WIDTH / 2, GAME_HEIGHT / 2);
                ctx.rotate(Math.PI);
                ctx.translate(-GAME_WIDTH / 2, -GAME_HEIGHT / 2);
            }

            drawPitch();
            entities.forEach(e => e.draw());
            drawAiming();
            ctx.restore();
        }

        if (gameState === 'SCORING' || gameState === 'FOUL') {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(-0.1);
            
            ctx.font = '900 100px Arial';
            ctx.fillStyle = gameState === 'SCORING' ? '#fbbf24' : '#ef4444';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            
            const text = gameState === 'SCORING' ? 'GOAL!' : 'FOUL!';
            ctx.strokeText(text, 0, 0);
            ctx.fillText(text, 0, 0);
            
            if (gameState === 'FOUL') {
                 ctx.font = 'bold 30px Arial';
                 ctx.fillStyle = '#fff';
                 ctx.shadowBlur = 0;
                 ctx.fillText('No direct goals from kickoff!', 0, 60);
            }
            
            ctx.restore();
        }

        requestAnimationFrame(loop);
    }

    // Input
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        
        // Raw Canvas Coords
        let x = (clientX - rect.left);
        let y = (clientY - rect.top);
        
        // To Logical Game Coords
        x = (x - offsetX) / scale;
        y = (y - offsetY) / scale;

        if (isOnline && !isHost) {
            x = GAME_WIDTH - x;
            y = GAME_HEIGHT - y;
        }
        return { x, y };
    }

    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('touchstart', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('touchmove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchend', handleEnd);

    function handleStart(e) {
        if (gameState !== 'PLAYING') return;
        if (isVsAI && turn === 'RED') return; // Can't move AI
        
        if (isOnline) {
            if (isHost && turn !== 'BLUE') return;
            if (!isHost && turn !== 'RED') return;
        }

        const pos = getMousePos(e);
        for (let ent of entities) {
            if (ent.type === 'player' && ent.team === turn) {
                const dist = Math.sqrt((pos.x - ent.pos.x)**2 + (pos.y - ent.pos.y)**2);
                if (dist <= ent.radius * 1.5) {
                    selectedEntity = ent;
                    dragStart = pos;
                    dragCurrent = pos;
                    break;
                }
            }
        }
    }

    function handleMove(e) {
        if (!dragStart) return;
        // e.preventDefault(); // preventing default can break scrolling on mobile, use careful
        dragCurrent = getMousePos(e);
    }

    function handleEnd(e) {
        if (!dragStart || !selectedEntity) return;
        
        const pos = dragCurrent;
        let dx = dragStart.x - pos.x;
        let dy = dragStart.y - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 10) {
            const power = Math.min(dist / 10, MAX_POWER);
            const angle = Math.atan2(dy, dx);
            const velX = Math.cos(angle) * power;
            const velY = Math.sin(angle) * power;
            
            if (isOnline && !isHost) {
                const idx = entities.indexOf(selectedEntity);
                conn.send({
                    type: 'SHOOT',
                    index: idx,
                    vel: { x: velX, y: velY }
                });
                // Local prediction
                selectedEntity.vel.x = velX;
                selectedEntity.vel.y = velY;
                gameState = 'MOVING';
            } else {
                selectedEntity.vel.x = velX;
                selectedEntity.vel.y = velY;
                gameState = 'MOVING';
            }

            // Note: isKickoff is NOT cleared here. It clears when the move ends.
            // This is correct because the 'kickoff shot' is the one currently happening.
            
            selectedEntity = null;
            dragStart = null;
            dragCurrent = null;
        } else {
            selectedEntity = null;
            dragStart = null;
            dragCurrent = null;
        }
    }

    restartBtn.addEventListener('click', () => {
        if (isOnline) {
            location.reload();
            return;
        }
        gameOverModal.classList.add('hidden');
        gameContainer.classList.add('opacity-0');
        gameUI.classList.add('opacity-0');
        
        // Return to main menu
        startScreen.classList.remove('hidden');
        gameState = 'MENU';
    });

    initGame();
    requestAnimationFrame(loop);

</script>
</body>
</html>

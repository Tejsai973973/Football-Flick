<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Football Flick</title>
    <script src="https://cdn.jsdelivr.net/npm/@tailwindcss/browser@4"></script>
    <style>
        body {
            touch-action: none;
            overflow: hidden;
            background-color: #1a1a1a;
            margin: 0;
            padding: 0;
        }
        canvas {
            display: block;
        }
        /* Custom scrollbar for webkit */
        ::-webkit-scrollbar {
            width: 0px;
        }
    </style>
</head>
<body class="h-screen w-screen overflow-hidden font-sans text-white select-none relative bg-black" oncontextmenu="return false;">

    <!-- Start Screen -->
    <div id="start-screen" class="absolute inset-0 bg-[#1a1a1a] z-50 flex flex-col items-center justify-center transition-opacity duration-500">
        <h1 class="text-7xl font-black text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-green-400 mb-8 drop-shadow-lg tracking-tighter italic">FOOTBALL FLICK</h1>
        <button id="enter-btn" class="bg-white text-black font-bold text-2xl py-4 px-12 rounded-full hover:bg-gray-200 hover:scale-105 transition transform shadow-[0_0_20px_rgba(255,255,255,0.3)]">
            ENTER
        </button>
    </div>

    <!-- Mode Select Screen -->
    <div id="mode-screen" class="absolute inset-0 bg-[#1a1a1a] z-40 flex flex-col items-center justify-center hidden">
        <h2 class="text-4xl font-bold text-white mb-10">SELECT MODE</h2>
        <div class="flex gap-8">
            <button id="ai-btn" class="bg-blue-600 hover:bg-blue-500 text-white font-bold py-6 px-10 rounded-2xl transition transform hover:scale-105 shadow-lg text-xl flex flex-col items-center gap-2 border-b-4 border-blue-800">
                <span>ü§ñ</span>
                <span>PLAY WITH AI</span>
            </button>
            <button id="pvp-btn" class="bg-red-600 hover:bg-red-500 text-white font-bold py-6 px-10 rounded-2xl transition transform hover:scale-105 shadow-lg text-xl flex flex-col items-center gap-2 border-b-4 border-red-800">
                <span>üë•</span>
                <span>2 PLAYER</span>
            </button>
        </div>
    </div>

    <!-- Formation Select Screen -->
    <div id="formation-screen" class="absolute inset-0 bg-[#1a1a1a] z-30 flex flex-col items-center justify-center hidden">
        <h2 class="text-4xl font-bold text-white mb-8">SELECT FORMATION</h2>
        <div class="flex flex-col md:flex-row gap-6">
            <button id="form-balanced" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition transform hover:scale-105 shadow-lg text-lg flex flex-col items-center border-b-4 border-gray-900 w-48">
                <span class="text-2xl mb-2">‚öñÔ∏è</span>
                <span>BALANCED</span>
                <span class="text-xs text-gray-400 mt-1">1 - 2 - 2</span>
            </button>
            <button id="form-defensive" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition transform hover:scale-105 shadow-lg text-lg flex flex-col items-center border-b-4 border-gray-900 w-48">
                <span class="text-2xl mb-2">üõ°Ô∏è</span>
                <span>DEFENSIVE</span>
                <span class="text-xs text-gray-400 mt-1">1 - 3 - 1</span>
            </button>
            <button id="form-offensive" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-4 px-8 rounded-xl transition transform hover:scale-105 shadow-lg text-lg flex flex-col items-center border-b-4 border-gray-900 w-48">
                <span class="text-2xl mb-2">‚öîÔ∏è</span>
                <span>OFFENSIVE</span>
                <span class="text-xs text-gray-400 mt-1">1 - 1 - 3</span>
            </button>
        </div>
    </div>

    <!-- UI Header -->
    <div id="game-ui" class="absolute top-4 w-full px-8 flex justify-between items-center z-10 pointer-events-none opacity-0 transition-opacity duration-500">
        <div class="flex flex-col items-center w-24">
            <span class="text-blue-400 font-bold text-xl">BLUE</span>
            <span id="score-blue" class="text-4xl font-black">0</span>
        </div>
        
        <div class="bg-gray-800/80 px-6 py-2 rounded-full border border-gray-600 min-w-[200px] text-center shadow-lg backdrop-blur-sm flex flex-col items-center">
            <span id="turn-indicator" class="font-bold text-lg text-blue-400">BLUE'S TURN</span>
            <span id="timer-display" class="text-3xl font-mono font-black text-white my-1 drop-shadow-md">15.0</span>
            <div class="text-xs text-gray-400">FIRST TO 2 WINS</div>
        </div>

        <div class="flex flex-col items-center w-24">
            <span class="text-red-400 font-bold text-xl">RED</span>
            <span id="score-red" class="text-4xl font-black">0</span>
        </div>
    </div>

    <!-- Game Container -->
    <div id="game-container" class="absolute inset-0 w-full h-full bg-[#2d6a4f] opacity-0 transition-opacity duration-500">
        <canvas id="gameCanvas" class="w-full h-full"></canvas>
        
        <!-- Game Over Modal -->
        <div id="game-over-modal" class="hidden absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-20">
            <h2 id="winner-text" class="text-6xl font-black mb-2 text-white drop-shadow-lg italic">BLUE WINS!</h2>
            <p id="final-score" class="text-2xl text-gray-300 mb-8 font-mono">3 - 1</p>
            <button id="restart-btn" class="pointer-events-auto bg-green-500 hover:bg-green-600 text-white font-bold py-3 px-8 rounded-full transition transform hover:scale-105 shadow-lg text-xl border-b-4 border-green-700">
                Main Menu
            </button>
        </div>
    </div>

    <div id="instructions" class="absolute bottom-4 left-0 right-0 text-center text-white/50 text-sm pointer-events-none opacity-0 px-4">
        Touch and drag to shoot. First to 2 goals wins. No direct goals from kickoff!
    </div>

<script>
    // --- Constants & Config ---
    let CANVAS_WIDTH = window.innerWidth;
    let CANVAS_HEIGHT = window.innerHeight;
    
    // Pitch dimensions with padding
    // Dynamic padding: 15% of screen dimension to make court smaller and give more drag space
    let PITCH_PADDING = Math.max(50, Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.15);

    let PITCH_X = PITCH_PADDING;
    let PITCH_Y = PITCH_PADDING;
    let PITCH_WIDTH = CANVAS_WIDTH - (PITCH_PADDING * 2);
    let PITCH_HEIGHT = CANVAS_HEIGHT - (PITCH_PADDING * 2);

    const FRICTION = 0.98;
    const WALL_BOUNCE = 0.7;
    const PLAYER_BOUNCE = 0.8;
    const MAX_POWER = 15;
    let GOAL_WIDTH = Math.min(CANVAS_HEIGHT * 0.25, CANVAS_WIDTH * 0.4); // Dynamic goal size, capped for portrait
    
    // Entity Radii - slightly dynamic based on screen size, but bounded
    // Increased minimum size for better touch targets on mobile
    let SCALE_FACTOR = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800;
    let RADIUS_PLAYER = Math.max(22, 22 * SCALE_FACTOR);
    let RADIUS_BALL = Math.max(13, 13 * SCALE_FACTOR);
    
    const MASS_PLAYER = 2;
    const MASS_BALL = 1;

    // Colors
    const COLOR_PITCH = '#3a7d44';
    const COLOR_LINES = 'rgba(255, 255, 255, 0.5)';
    const COLOR_BLUE = '#3b82f6';
    const COLOR_RED = '#ef4444';
    const COLOR_BALL = '#ffffff';

    // --- State ---
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const turnIndicator = document.getElementById('turn-indicator');
    const scoreBlueEl = document.getElementById('score-blue');
    const scoreRedEl = document.getElementById('score-red');
    const gameOverModal = document.getElementById('game-over-modal');
    const winnerText = document.getElementById('winner-text');
    const finalScoreText = document.getElementById('final-score');
    const restartBtn = document.getElementById('restart-btn');
    
    const startScreen = document.getElementById('start-screen');
    const modeScreen = document.getElementById('mode-screen');
    const formationScreen = document.getElementById('formation-screen');
    const gameContainer = document.getElementById('game-container');
    const gameUI = document.getElementById('game-ui');
    const instructions = document.getElementById('instructions');
    const timerDisplay = document.getElementById('timer-display');

    let selectedFormation = 'BALANCED'; // BALANCED, DEFENSIVE, OFFENSIVE
    
    // Timer State
    const TURN_TIME_LIMIT = 15.0;
    let turnTimer = TURN_TIME_LIMIT;
    let lastTime = 0;

    // Handle Resize
    window.addEventListener('resize', () => {
        CANVAS_WIDTH = window.innerWidth;
        CANVAS_HEIGHT = window.innerHeight;
        
        // Recalculate dynamic values
        PITCH_PADDING = Math.max(50, Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) * 0.15);
        
        PITCH_X = PITCH_PADDING;
        PITCH_Y = PITCH_PADDING;
        PITCH_WIDTH = CANVAS_WIDTH - (PITCH_PADDING * 2);
        PITCH_HEIGHT = CANVAS_HEIGHT - (PITCH_PADDING * 2);
        
        SCALE_FACTOR = Math.min(CANVAS_WIDTH, CANVAS_HEIGHT) / 800;
        RADIUS_PLAYER = Math.max(22, 22 * SCALE_FACTOR);
        RADIUS_BALL = Math.max(13, 13 * SCALE_FACTOR);
        
        // Resize existing entities proportional to new scale? 
        // For simplicity, we just update future entities or reset. 
        // Ideally, we'd update current entity radii, but they get reset on goals anyway.
        // We will just update radii for next draw calls for consistency if we wanted, 
        // but since `radius` is a property of Entity, we'd have to iterate.
        // Let's just update the global constants which will affect new entities/resets.
        // To fix current view, let's update current entities radius:
        entities.forEach(e => {
            if(e.type === 'player') e.radius = RADIUS_PLAYER;
            if(e.type === 'ball') e.radius = RADIUS_BALL;
        });

        canvas.width = CANVAS_WIDTH;
        canvas.height = CANVAS_HEIGHT;
        GOAL_WIDTH = Math.min(CANVAS_HEIGHT * 0.25, CANVAS_WIDTH * 0.4);
    });

    // Set canvas resolution
    canvas.width = CANVAS_WIDTH;
    canvas.height = CANVAS_HEIGHT;

    let gameState = 'MENU'; // MENU, MODE_SELECT, PLAYING, MOVING, SCORING, GAME_OVER, FOUL
    let turn = 'BLUE'; 
    let scores = { blue: 0, red: 0 };
    let entities = [];
    let ball;
    
    // Game Mode State
    let isVsAI = false;
    let isKickoff = true; // Tracks if it's the first move after a reset

    // Input State
    let dragStart = null;
    let dragCurrent = null;
    let selectedEntity = null;

    // --- Physics Engine Classes ---
    class Vector {
        constructor(x, y) { this.x = x; this.y = y; }
        add(v) { return new Vector(this.x + v.x, this.y + v.y); }
        sub(v) { return new Vector(this.x - v.x, this.y - v.y); }
        mult(n) { return new Vector(this.x * n, this.y * n); }
        mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
        normalize() { 
            const m = this.mag(); 
            return m === 0 ? new Vector(0,0) : new Vector(this.x / m, this.y / m); 
        }
        dot(v) { return this.x * v.x + this.y * v.y; }
    }

    class Entity {
        constructor(x, y, radius, mass, type, team = null) {
            this.pos = new Vector(x, y);
            this.vel = new Vector(0, 0);
            this.radius = radius;
            this.mass = mass;
            this.type = type;
            this.team = team;
        }

        update() {
            this.pos = this.pos.add(this.vel);
            this.vel = this.vel.mult(FRICTION);
            
            if (this.vel.mag() < 0.05) {
                this.vel = new Vector(0, 0);
            }
        }

        draw() {
            ctx.beginPath();
            ctx.arc(this.pos.x, this.pos.y, this.radius, 0, Math.PI * 2);
            
            ctx.shadowColor = 'rgba(0,0,0,0.3)';
            ctx.shadowBlur = 5;
            ctx.shadowOffsetX = 2;
            ctx.shadowOffsetY = 2;

            if (this.type === 'ball') {
                ctx.fillStyle = COLOR_BALL;
                ctx.fill();
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius * 0.3, 0, Math.PI * 2);
                ctx.fill();
                const angleOffset = (this.pos.x + this.pos.y) * 0.05;
                for (let i = 0; i < 5; i++) {
                    const a = angleOffset + (i * Math.PI * 2) / 5;
                    const px = this.pos.x + Math.cos(a) * (this.radius * 0.65);
                    const py = this.pos.y + Math.sin(a) * (this.radius * 0.65);
                    ctx.beginPath();
                    ctx.arc(px, py, this.radius * 0.2, 0, Math.PI * 2);
                    ctx.fill();
                }
                ctx.strokeStyle = 'rgba(0,0,0,0.1)';
                ctx.lineWidth = 1;
                ctx.stroke();
            } else {
                ctx.fillStyle = this.team === 'BLUE' ? COLOR_BLUE : COLOR_RED;
                if (this.team === turn && gameState === 'PLAYING') {
                    ctx.shadowColor = this.team === 'BLUE' ? '#60a5fa' : '#f87171';
                    ctx.shadowBlur = 15;
                }
                ctx.fill();
                ctx.shadowBlur = 0;
                
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, this.radius * 0.7, 0, Math.PI * 2);
                ctx.strokeStyle = 'rgba(255,255,255,0.3)';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                if (selectedEntity === this && gameState === 'PLAYING') {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 4, 0, Math.PI * 2);
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 3;
                    ctx.stroke();
                } else if (this.team === turn && gameState === 'PLAYING') {
                    ctx.beginPath();
                    ctx.arc(this.pos.x, this.pos.y, this.radius + 2, 0, Math.PI * 2);
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.4)';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }
            ctx.shadowColor = 'transparent';
        }
    }

    // --- Game Logic ---

    function initGame() {
        entities = [];
        ball = new Entity(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT / 2, RADIUS_BALL, MASS_BALL, 'ball');
        entities.push(ball);
        resetPositions();
        
        // Setup Menu Listeners
        document.getElementById('enter-btn').addEventListener('click', () => {
            startScreen.classList.add('hidden');
            modeScreen.classList.remove('hidden');
            modeScreen.classList.add('flex');
            gameState = 'MODE_SELECT';
        });

        document.getElementById('pvp-btn').addEventListener('click', () => {
            isVsAI = false;
            showFormationSelect();
        });

        document.getElementById('ai-btn').addEventListener('click', () => {
            isVsAI = true;
            showFormationSelect();
        });

        document.getElementById('form-balanced').addEventListener('click', () => {
            selectedFormation = 'BALANCED';
            startGame();
        });
        document.getElementById('form-defensive').addEventListener('click', () => {
            selectedFormation = 'DEFENSIVE';
            startGame();
        });
        document.getElementById('form-offensive').addEventListener('click', () => {
            selectedFormation = 'OFFENSIVE';
            startGame();
        });
    }

    function showFormationSelect() {
        modeScreen.classList.add('hidden');
        modeScreen.classList.remove('flex');
        formationScreen.classList.remove('hidden');
        formationScreen.classList.add('flex');
    }

    function startGame() {
        formationScreen.classList.add('hidden');
        formationScreen.classList.remove('flex');
        
        gameContainer.classList.remove('opacity-0');
        gameUI.classList.remove('opacity-0');
        instructions.classList.remove('opacity-0');
        
        // isVsAI is already set
        scores = { blue: 0, red: 0 };
        turn = 'BLUE';
        
        resetPositions();
    }

    function resetPositions() {
        entities = entities.filter(e => e.type === 'ball');
        
        ball.pos = new Vector(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT / 2);
        ball.vel = new Vector(0, 0);

        const w = PITCH_WIDTH;
        const h = PITCH_HEIGHT;
        const startX = PITCH_X;
        const startY = PITCH_Y;
        
        const goalDist = w * 0.08;
        const defDist = w * 0.22;
        const attDist = w * 0.38;
        const spreadY = h * 0.25;
        const attSpreadY = h * 0.15;
        const centerY = startY + h / 2;

        // 5v5 Formations
        // Blue Team (Left)
        
        // Always 1 GK
        entities.push(new Entity(startX + goalDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));

        if (selectedFormation === 'DEFENSIVE') {
            // 1-3-1
            // 3 Defenders
            entities.push(new Entity(startX + defDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + defDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + defDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            // 1 Attacker
            entities.push(new Entity(startX + attDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
        } else if (selectedFormation === 'OFFENSIVE') {
            // 1-1-3
            // 1 Defender
            entities.push(new Entity(startX + defDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            // 3 Attackers
            entities.push(new Entity(startX + attDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + attDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + attDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
        } else {
            // BALANCED (1-2-2)
            // 2 Defenders
            entities.push(new Entity(startX + defDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + defDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            // 2 Attackers
            entities.push(new Entity(startX + attDist, centerY - attSpreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
            entities.push(new Entity(startX + attDist, centerY + attSpreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'BLUE'));
        }

        // Red Team (Right)
        // GK
        entities.push(new Entity(startX + w - goalDist, centerY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
        // Defenders
        entities.push(new Entity(startX + w - defDist, centerY - spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
        entities.push(new Entity(startX + w - defDist, centerY + spreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
        // Attackers
        entities.push(new Entity(startX + w - attDist, centerY - attSpreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
        entities.push(new Entity(startX + w - attDist, centerY + attSpreadY, RADIUS_PLAYER, MASS_PLAYER, 'player', 'RED'));
        
        gameState = 'PLAYING';
        isKickoff = true; // Set kickoff flag
        updateUI();

        // If AI's turn and AI mode (happens if Red conceded), trigger AI
        if (isVsAI && turn === 'RED') {
            setTimeout(makeAIMove, 1000);
        }
    }

    function checkCollisions() {
        // Walls
        for (let e of entities) {
            if (e.pos.y - e.radius < PITCH_Y) { e.pos.y = PITCH_Y + e.radius; e.vel.y *= -WALL_BOUNCE; } 
            else if (e.pos.y + e.radius > PITCH_Y + PITCH_HEIGHT) { e.pos.y = PITCH_Y + PITCH_HEIGHT - e.radius; e.vel.y *= -WALL_BOUNCE; }

            const goalTop = (CANVAS_HEIGHT - GOAL_WIDTH) / 2;
            const goalBottom = (CANVAS_HEIGHT + GOAL_WIDTH) / 2;

            if (e.pos.x - e.radius < PITCH_X) {
                const inGoal = e.pos.y > goalTop && e.pos.y < goalBottom;
                if (inGoal && e.type === 'ball') {
                    if (e.pos.x < PITCH_X - e.radius) handleGoal('RED');
                } else {
                    e.pos.x = PITCH_X + e.radius; e.vel.x *= -WALL_BOUNCE;
                }
            } else if (e.pos.x + e.radius > PITCH_X + PITCH_WIDTH) {
                const inGoal = e.pos.y > goalTop && e.pos.y < goalBottom;
                if (inGoal && e.type === 'ball') {
                    if (e.pos.x > PITCH_X + PITCH_WIDTH + e.radius) handleGoal('BLUE');
                } else {
                    e.pos.x = PITCH_X + PITCH_WIDTH - e.radius; e.vel.x *= -WALL_BOUNCE;
                }
            }
        }

        // Entity-Entity
        for (let iter = 0; iter < 4; iter++) {
            for (let i = 0; i < entities.length; i++) {
                for (let j = i + 1; j < entities.length; j++) {
                    let e1 = entities[i];
                    let e2 = entities[j];
                    let distVec = e1.pos.sub(e2.pos);
                    let dist = distVec.mag();
                    let minDist = e1.radius + e2.radius;

                    if (dist < minDist) {
                        let normal = distVec.normalize();
                        let overlap = minDist - dist;
                        let correction = normal.mult(overlap / 2);
                        e1.pos = e1.pos.add(correction);
                        e2.pos = e2.pos.sub(correction);

                        if (iter === 0) {
                            let relVel = e1.vel.sub(e2.vel);
                            let velAlongNormal = relVel.dot(normal);
                            if (velAlongNormal > 0) continue;
                            let restitution = PLAYER_BOUNCE;
                            let jVal = -(1 + restitution) * velAlongNormal;
                            jVal /= (1 / e1.mass + 1 / e2.mass);
                            let impulse = normal.mult(jVal);
                            e1.vel = e1.vel.add(impulse.mult(1 / e1.mass));
                            e2.vel = e2.vel.sub(impulse.mult(1 / e2.mass));
                        }
                    }
                }
            }
        }
    }

    function isMoving() {
        for (let e of entities) {
            if (e.vel.mag() > 0.1) return true;
        }
        return false;
    }

    function handleGoal(scoringTeam) {
        if (gameState === 'SCORING' || gameState === 'FOUL') return;
        
        // Foul Check: Direct goal from kickoff is disallowed
        if (isKickoff) {
            handleFoul(scoringTeam);
            return;
        }

        gameState = 'SCORING';
        
        if (scoringTeam === 'BLUE') scores.blue++;
        else scores.red++;
        
        updateUI();
        
        setTimeout(() => {
            if (scores.blue >= 2 || scores.red >= 2) {
                endGame();
            } else {
                resetPositions();
                turn = scoringTeam === 'BLUE' ? 'RED' : 'BLUE'; // Conceding team kicks off
                gameState = 'PLAYING';
                updateUI();
            }
        }, 1500);
    }

    function handleFoul(scoringTeam) {
        gameState = 'FOUL';
        // UI Feedback for foul
        setTimeout(() => {
            resetPositions();
            turn = turn === 'BLUE' ? 'RED' : 'BLUE'; 
            gameState = 'PLAYING';
            updateUI();
        }, 2000);
    }

    function endGame() {
        gameState = 'GAME_OVER';
        
        let winner;
        if (scores.blue > scores.red) winner = 'BLUE';
        else if (scores.red > scores.blue) winner = 'RED';
        else winner = 'DRAW';
        
        winnerText.textContent = `${winner} WINS!`;
        winnerText.className = `text-6xl font-black mb-2 drop-shadow-lg italic ${winner === 'BLUE' ? 'text-blue-500' : (winner === 'RED' ? 'text-red-500' : 'text-gray-200')}`;
        
        finalScoreText.textContent = `${scores.blue} - ${scores.red}`;
        
        gameOverModal.classList.remove('hidden');
    }

    function makeAIMove() {
        if (gameState !== 'PLAYING' || turn !== 'RED') return;

        // Simple AI
        const redPlayers = entities.filter(e => e.type === 'player' && e.team === 'RED');
        
        // Find best player to shoot (closest to ball)
        let bestPlayer = null;
        let minDist = Infinity;
        
        for (let p of redPlayers) {
            const d = p.pos.sub(ball.pos).mag();
            if (d < minDist) {
                minDist = d;
                bestPlayer = p;
            }
        }
        
        if (bestPlayer) {
            // Calculate shot vector
            // Target: slightly offset from ball center opposite to goal
            const goalPos = new Vector(PITCH_X, CANVAS_HEIGHT / 2); // Blue goal
            const ballToGoal = goalPos.sub(ball.pos).normalize();
            
            // We want to hit the ball such that it goes to goal
            // Hit point on ball is opposite to velocity direction we want for ball
            // Desired Ball Vel = Ball->Goal
            // Hit pos = BallPos - BallRadius * BallToGoal
            
            const hitPos = ball.pos.sub(ballToGoal.mult(RADIUS_BALL + RADIUS_PLAYER));
            
            // Vector from player to hitPos
            let shotVec = hitPos.sub(bestPlayer.pos);
            
            // Add some noise for realism
            shotVec.x += (Math.random() - 0.5) * 10;
            shotVec.y += (Math.random() - 0.5) * 10;
            
            // Power
            const power = Math.min(shotVec.mag() * 0.15, MAX_POWER); // Adjust multiplier
            const finalVel = shotVec.normalize().mult(power);
            
            bestPlayer.vel = finalVel;
            gameState = 'MOVING';
            // isKickoff will be handled in the loop when movement stops
        }
    }

    function updateUI() {
        scoreBlueEl.textContent = scores.blue;
        scoreRedEl.textContent = scores.red;
        turnIndicator.textContent = `${turn}'S TURN`;
        turnIndicator.className = `font-bold text-lg ${turn === 'BLUE' ? 'text-blue-400' : 'text-red-400'}`;
        
        // Reset Timer
        turnTimer = TURN_TIME_LIMIT;
        timerDisplay.textContent = turnTimer.toFixed(1);
        timerDisplay.style.color = 'white';

        // Trigger AI if needed
        if (isVsAI && turn === 'RED' && gameState === 'PLAYING') {
            // Small delay for natural feel
            setTimeout(makeAIMove, 800);
        }
    }

    function drawPitch() {
        // Draw background (gutter)
        ctx.fillStyle = '#111';
        ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);

        // Dynamic pitch elements
        const stripeWidth = PITCH_WIDTH / 10;
        for (let i = 0; i < 10; i++) {
            ctx.fillStyle = i % 2 === 0 ? '#3a7d44' : '#326b3a';
            ctx.fillRect(PITCH_X + i * stripeWidth, PITCH_Y, stripeWidth, PITCH_HEIGHT);
        }

        ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
        ctx.lineWidth = 3;
        ctx.strokeRect(PITCH_X, PITCH_Y, PITCH_WIDTH, PITCH_HEIGHT);

        // Center line
        ctx.beginPath();
        ctx.moveTo(PITCH_X + PITCH_WIDTH / 2, PITCH_Y);
        ctx.lineTo(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT);
        ctx.stroke();

        // Center circle
        const centerRadius = Math.min(PITCH_WIDTH, PITCH_HEIGHT) * 0.15;
        ctx.beginPath();
        ctx.arc(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT / 2, centerRadius, 0, Math.PI * 2);
        ctx.stroke();
        
        ctx.beginPath();
        ctx.arc(PITCH_X + PITCH_WIDTH / 2, PITCH_Y + PITCH_HEIGHT / 2, 5, 0, Math.PI * 2);
        ctx.fillStyle = '#fff';
        ctx.fill();

        // Goals
        const goalY = (CANVAS_HEIGHT - GOAL_WIDTH) / 2;
        const goalDepth = PITCH_WIDTH * 0.05;
        
        // Left Goal Box
        ctx.strokeRect(PITCH_X - goalDepth, goalY, goalDepth, GOAL_WIDTH);
        // Right Goal Box
        ctx.strokeRect(PITCH_X + PITCH_WIDTH, goalY, goalDepth, GOAL_WIDTH);
        
        // Nets
        ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
        ctx.fillRect(PITCH_X - goalDepth, goalY, goalDepth, GOAL_WIDTH);
        ctx.fillRect(PITCH_X + PITCH_WIDTH, goalY, goalDepth, GOAL_WIDTH);
    }

    function drawAiming() {
        if (dragStart && dragCurrent && selectedEntity) {
            ctx.beginPath();
            ctx.moveTo(selectedEntity.pos.x, selectedEntity.pos.y);
            let dx = dragCurrent.x - dragStart.x;
            let dy = dragCurrent.y - dragStart.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const maxDrag = 150; 
            const scale = Math.min(dist, maxDrag) / dist || 0;
            let aimX = selectedEntity.pos.x - dx * scale;
            let aimY = selectedEntity.pos.y - dy * scale;

            ctx.lineTo(aimX, aimY);
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
            ctx.lineWidth = 4;
            ctx.setLineDash([10, 5]);
            ctx.stroke();
            ctx.setLineDash([]);
            
            const angle = Math.atan2(dy, dx);
            const headLen = 15;
            ctx.beginPath();
            ctx.moveTo(aimX, aimY);
            ctx.lineTo(aimX + headLen * Math.cos(angle + Math.PI / 6), aimY + headLen * Math.sin(angle + Math.PI / 6));
            ctx.moveTo(aimX, aimY);
            ctx.lineTo(aimX + headLen * Math.cos(angle - Math.PI / 6), aimY + headLen * Math.sin(angle - Math.PI / 6));
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.8)';
            ctx.lineWidth = 4;
            ctx.stroke();
            
            ctx.beginPath();
            ctx.arc(selectedEntity.pos.x, selectedEntity.pos.y, selectedEntity.radius + 8, 0, Math.PI * 2);
            ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(scale * 0.8, 0.8)})`;
            ctx.lineWidth = 2;
            ctx.stroke();
        }
    }

    function loop(timestamp) {
        if (!lastTime) lastTime = timestamp;
        const dt = (timestamp - lastTime) / 1000 || 0;
        lastTime = timestamp;

        if (gameState === 'PLAYING') {
            turnTimer -= dt;
            if (turnTimer <= 0) {
                // Timeout! Switch turn
                turnTimer = TURN_TIME_LIMIT;
                turn = turn === 'BLUE' ? 'RED' : 'BLUE';
                // Cancel any active interaction
                dragStart = null;
                selectedEntity = null;
                dragCurrent = null;
                updateUI();
            }
            // Visual Update
            timerDisplay.textContent = Math.max(0, turnTimer).toFixed(1);
            if (turnTimer <= 3.0) timerDisplay.style.color = '#ef4444'; 
            else timerDisplay.style.color = 'white';
        }

        if (gameState !== 'GAME_OVER' && gameState !== 'MENU' && gameState !== 'MODE_SELECT') {
            checkCollisions();
            entities.forEach(e => e.update());

            if (gameState === 'MOVING') {
                if (!isMoving()) {
                    gameState = 'PLAYING';
                    isKickoff = false; // Turn ended, so kickoff state is over
                    turn = turn === 'BLUE' ? 'RED' : 'BLUE';
                    updateUI();
                }
            }
        }

        if (gameState !== 'MENU' && gameState !== 'MODE_SELECT') {
            drawPitch();
            entities.forEach(e => e.draw());
            drawAiming();
        }

        if (gameState === 'SCORING' || gameState === 'FOUL') {
            ctx.save();
            ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.fillRect(0, 0, CANVAS_WIDTH, CANVAS_HEIGHT);
            
            ctx.translate(CANVAS_WIDTH / 2, CANVAS_HEIGHT / 2);
            ctx.rotate(-0.1);
            
            ctx.font = '900 100px Arial';
            ctx.fillStyle = gameState === 'SCORING' ? '#fbbf24' : '#ef4444';
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 4;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 20;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 5;
            
            const text = gameState === 'SCORING' ? 'GOAL!' : 'FOUL!';
            ctx.strokeText(text, 0, 0);
            ctx.fillText(text, 0, 0);
            
            if (gameState === 'FOUL') {
                 ctx.font = 'bold 30px Arial';
                 ctx.fillStyle = '#fff';
                 ctx.shadowBlur = 0;
                 ctx.fillText('No direct goals from kickoff!', 0, 60);
            }
            
            ctx.restore();
        }

        requestAnimationFrame(loop);
    }

    // Input
    function getMousePos(evt) {
        const rect = canvas.getBoundingClientRect();
        const clientX = evt.touches ? evt.touches[0].clientX : evt.clientX;
        const clientY = evt.touches ? evt.touches[0].clientY : evt.clientY;
        const scaleX = canvas.width / rect.width;
        const scaleY = canvas.height / rect.height;
        return { x: (clientX - rect.left) * scaleX, y: (clientY - rect.top) * scaleY };
    }

    canvas.addEventListener('mousedown', handleStart);
    canvas.addEventListener('touchstart', handleStart);
    canvas.addEventListener('mousemove', handleMove);
    canvas.addEventListener('touchmove', handleMove);
    canvas.addEventListener('mouseup', handleEnd);
    canvas.addEventListener('touchend', handleEnd);

    function handleStart(e) {
        if (gameState !== 'PLAYING') return;
        if (isVsAI && turn === 'RED') return; // Can't move AI
        
        const pos = getMousePos(e);
        for (let ent of entities) {
            if (ent.type === 'player' && ent.team === turn) {
                const dist = Math.sqrt((pos.x - ent.pos.x)**2 + (pos.y - ent.pos.y)**2);
                if (dist <= ent.radius * 1.5) {
                    selectedEntity = ent;
                    dragStart = pos;
                    dragCurrent = pos;
                    break;
                }
            }
        }
    }

    function handleMove(e) {
        if (!dragStart) return;
        // e.preventDefault(); // preventing default can break scrolling on mobile, use careful
        dragCurrent = getMousePos(e);
    }

    function handleEnd(e) {
        if (!dragStart || !selectedEntity) return;
        
        const pos = dragCurrent;
        let dx = dragStart.x - pos.x;
        let dy = dragStart.y - pos.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        if (dist > 10) {
            const power = Math.min(dist / 10, MAX_POWER);
            const angle = Math.atan2(dy, dx);
            selectedEntity.vel.x = Math.cos(angle) * power;
            selectedEntity.vel.y = Math.sin(angle) * power;
            
            gameState = 'MOVING';
            // Note: isKickoff is NOT cleared here. It clears when the move ends.
            // This is correct because the 'kickoff shot' is the one currently happening.
            
            selectedEntity = null;
            dragStart = null;
            dragCurrent = null;
        } else {
            selectedEntity = null;
            dragStart = null;
            dragCurrent = null;
        }
    }

    restartBtn.addEventListener('click', () => {
        gameOverModal.classList.add('hidden');
        gameContainer.classList.add('opacity-0');
        gameUI.classList.add('opacity-0');
        
        // Return to main menu
        startScreen.classList.remove('hidden');
        gameState = 'MENU';
    });

    initGame();
    requestAnimationFrame(loop);

</script>
</body>
</html>
